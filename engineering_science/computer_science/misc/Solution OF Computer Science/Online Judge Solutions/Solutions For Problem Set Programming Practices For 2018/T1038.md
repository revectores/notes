##### T1038

1. How to construct `__repr__` function of C++ class forma (overloading `operator<<`):

   ```c++
   friend std::ostream& operator<<(std::ostream& os, const Obj &obj){
       os << obj.data;
      	return os;
   }
   ```

   Some notations: 1. The function must be declared as a `friend`, so the instance of class itself should be passed as a parameter. 2. This function receive the output stream object `std::ostream` and **return it back** after we push the data into it.

   

2. The usage of `std::sort` function:

   ```c++
   std::sort(vec1.begin(), vec2.end(), cmp_fun);
   ```

   Notice this function change the input containers and return nothing. This function can be used in `vector` and `string`, which could sort the `char` list of string by the lexicographical order.

   The construction of `cmp_fun`:

   ```c++
   int cmp_fun(int a, int b){
   	return a < b;
   }
   ```

   This function return `-1, 0, 1` to indicate the order of elements, if you `return a < b` , it will be increased, otherwise if you `return a > b` it will be decreased.



##### T1048

1. Method to split string by given delimiter:

   ```c++
   std::vector<std::string> split(std::string string, std::delimiter){
       std::vector<std::string> sections;
       
       size_t pos = 0;
       std::string section;
       
       while((pos = string.find(delimiter)) != std::string::npos){
           section = string.substr(0, pos);
           sections.push_back(section);
           string.erase(0, pos+delimiter.length());
       }
       sections.push_back(string);
       return sections;
   }
   ```

   We use a loop of `find`, and  `erase` to find all the occurances of `delimiter` (this code can be refined to find all the occurance of given pattern), and use `substr` method to get the `section` between `delimiter`.

   Usage of string method:

   ```c++
   string.find(substr);
   string.substr(start_pos, end_pos);
   string.erase(start_pos, end_pos);
   // end_pos is not included in `substr` and `erase`.
   ```



##### T1032

1. A small trick that comes to mind: The `find` method finds the first occurance of substr, if you want to get the final one you can **REVERSE** both the string and the substr, and calculate the start index carefully XD.



##### Some Notes:

1. No `push_front` method for `std::vector`, use `insert(vec.begin(), 1)`.

2. Find a value and get the offset of the location:

   ```c++
   std::vector<int>::iterator it = find(vec.begin(), vec.end(), v);
   int index = std::distance(vec.begin(), it);
   ```

   Differ from the `string.find()` method, the `std::find` function returns an address instead a offset value (anyway, based on the design of API, it even doesn't know it's a vector, but only a continous addresses provided). Use `std::distance` to get the offsets from the beginning. 

3. How to initialize a `std::string` by `char`?

   ```c++
   std::string s(1, 'c'); // SOU
   ```

   How to make multiple spaces?

   ```c++
   std::string s(50, ' '); // SOU
   ```

   How to concatenate strings?

   ```c++
   s = s1 + s2; // SOU
   ```

4. The specifier of `long int` and `long long int`": `%ld, %lld`.

5. Insert of `std::string`: `string.insert(index, count, 'c')` or `string.insert(index, "str")`.

6. `No matching function` Error for the modification method like `insert` may indicate you used the `const&`.

7. Show the type of a variable: `typeid(var).name()`, the result might be not so good-looking or human-readable.

