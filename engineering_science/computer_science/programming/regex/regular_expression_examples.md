# Regular Expression Examples

##### # Match IP Address

```regex
\b((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9]))\b
```



##### # Match Mail Address

`\b(\w+\.)*\w+@(\w+.)+\w+\b`

关于邮箱正则我们产生过如下的思路: 

首先考察一下邮箱地址的结构

```
ben@forta.com
ben.forta@forta.com
cistron@yahoo.co.jp
123456_kk@163.com
```

这些都是是合法的邮箱名, 这表明邮箱地址首先被@划分为两个部分, 且前后两部分都可以被一个或多个的句点.划分开(其中前面可以没有句点, 而后面必须至少有一个句点), 每一个小部分中都可以使用数字、字母和下划线(这正是\w所给出的集合！). 由此, 我们很容易构造出下面的正则表达式

`\w[\w.]*\w@\w[\w.]*\w\.\w+`

这看起来有点复杂, 我们稍微解释一下: 总览全局, 首先注意到@前后的形式是不同的, 这是因为邮箱的前半部分可以没有句点, 因而句点应当只存在于可选字符集合中, 但后半部分则不同, **必须至少存在一个句点**, 因而有一个位于可选字符集合之外, 否则例如aaa@bbb这样的不合法地址也会被匹配进来. 注意到.本身是一个元字符, 因此放在外面时必须转义成\.

接下来进行具体的构造: 我们先考虑@前的部分, 总体来看就是由许多的\w和点构成, 因此我们先构造出一个[\w.]+, 之所以用+是因为我们知道@前面至少应该有一个字符, 但这个写法会造成一个问题: 开头和结尾是句点的也会被匹配(包括只有一个句点的), 例如 .aaa.bbb@ccc.com  aaa.bbb.@ccc.com 甚至是 .@ccc.com(这个就未免太搞笑了), 而我们知道这样的格式是不合法的, 句点起到的是分隔作用, 两边必须有\w的存在, 大概像这样子: 

`\w[\w.]*\w`

WARNING: 写到这里我们注意到事实上这样写不能避免aaa...bbb的问题(除此之外这个写法也会引起\w\w导致的“至少两个字母”问题), 实际上邮箱正则的构造是上下文相关的, 需要判断任何一个.两边是否存在.(或者空格、制表符等等)的问题

另一个解决思路: 把\.独立出来, 因为如果我们写成[\w.]+或者[\w.]*这样, 把\w和.绑定在一起, 就不可能避免多个点连续存在的问题, 如果中括号可以嵌套的话, 把\.放在另一个嵌套层次, 或许问题也可以得以解决(但并不知道可以不可以嵌套), 有待以后更多内容的添加. 这里我们先留个坑. 


